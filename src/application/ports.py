# app/auth/application/ports.py
from __future__ import annotations
from typing import Protocol, Iterable
from dataclasses import dataclass
from domain.entities import *
from typing import TypedDict
from datetime import timedelta

# Erros da aplicação (não HTTP)


class NotFound(Exception):
    ...


class AlreadyExists(Exception):
    ...


class Unauthorized(Exception):
    ...


class UserRepository(Protocol):
    def create(self, user: User) -> None: ...
    def read(self, user_id: Id) -> User: ...
    def read_all(self, limit: int = 50, offset: int = 0) -> Iterable[User]: ...
    def update(self, user: User) -> None: ...
    def delete(self, user_id: Id) -> None: ...
    def save(self, user: User) -> None: ...
    def exists_by_email(self, email: Email) -> bool: ...
    def get_auth_view_by_email(
        self, email: Email) -> tuple[Id, PasswordHash, str]: ...


class RefreshTokenRepository(Protocol):
    def create(self, token: RefreshToken) -> None: ...
    def read(self, token_id: str) -> RefreshToken: ...
    def update(self, token: RefreshToken) -> None: ...
    def delete(self, token_id: str) -> None: ...
    def save(self, token: RefreshToken) -> None: ...
    def revoke(self, token_id: str) -> None: ...


class OfferRepository(Protocol):
    def create(self, offer: Offer) -> None: ...
    def read(self, offer_id: str) -> Offer: ...
    def update(self, offer: Offer) -> None: ...
    def delete(self, offer_id: str) -> None: ...
    def save(self, offer: Offer) -> None: ...
    def get_by_user_id(self, *, user_id: str, limit: int = 50,
                       offset: int = 0) -> Iterable[Offer]: ...

    def update_application(self, user_id: str) -> None: ...

    def list(self, *, limit: int = 50, offset: int = 0) -> Iterable[Offer]: ...


class PasswordHasher(Protocol):
    def hash(self, password: str) -> str: ...
    def verify(self, password: str, password_hash: str) -> bool: ...


class AccessTokenClaims(TypedDict):
    sub: str          # user id
    exp: int          # unix timestamp
    scope: str        # e.g. "user", "admin", "user:read user:write"
    typ: str          # "access"


class AccessTokenEncoder(Protocol):
    def encode(self, subject: str, ttl: timedelta) -> str: ...
    def decode(self, token: str) -> AccessTokenClaims: ...
